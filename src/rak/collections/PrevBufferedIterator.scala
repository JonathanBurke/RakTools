package rak.collections

/**
 * This class is an iterator that holds onto the previous item returned by next.  So far, this is used
 * solely for the takeIncluding method, which is identical to takeWhile except it appends the
 * the element that caused the takeWhile to terminate.
 */
class PrevBufferedIterator[T]( iter : Iterator[T] ) extends Iterator[T] {
  var prev : Option[T] = None


  override def hasNext: Boolean = iter.hasNext

  override def next(): T = {
    prev = Some(iter.next())
    prev.get
  }

  /**
   * Take everything up to and including the first element for which test returns false.
   * @param test A method that determines whether to continue taking elements from the iterator
   * @return A new iterator consisting of all elements up to including the first element in
   *         this iterator for which test returns false
   */
  def takeIncluding(test : (T => Boolean)) : Iterator[T] = {
    return new IteratorWithCall(takeWhile(test), getPrev)
  }

  /**
   * @return The previous element returned by next
   */
  def getPrev() : T = {
    if (prev.isDefined) {
      prev.get
    } else {
      throw new NoSuchElementException
    }
  }

  /**
   * An iterator that cycles through the elements in iter and then returns one final element
   * generated by calling the method getLastElement.
   */
  private class IteratorWithCall(iter : Iterator[T], getLastElement : (() => T)) extends Iterator[T] {
    private var called = false

    override def hasNext: Boolean = iter.hasNext || !called

    override def next(): T =
      if (iter.hasNext) {
        iter.next
      } else if (!called) {
        called = true
        getLastElement()
      } else {
        throw new NoSuchElementException
      }
  }
}


